import File, {
  Rights,
  Directory,
  RegularFile,
  DirectoryEntry,
  FdFlag,
} from "sys/file"
import Result from "result"
import Array from "array"
import List from "list"
import String from "string"
import Number from "number"
import { join } from "./path"
import {
  parent,
  toString as pathToString,
  fromString as pathFromString,
} from "path"
import { logSuccess, logError, logInfo, debug } from "./debug"
import { systemErrors } from "./syserror"

export enum FilePath {
  Fd(File.FileDescriptor),
  Path(String), /* fd = File.pwdfd */
  FdPath(File.FileDescriptor, String),
}

export record PathOpenOptions {
  lookupFlag: List<File.LookupFlag>,
  openFlags: List<File.OpenFlag>,
  rights: List<File.Rights>,
  inheriting: List<File.Rights>,
  rwFlags: List<File.FdFlag>,
}

export let normalisePath = (path: String) => pathToString(pathFromString(path))

/**
 *    Existance
 */

export let fdIsPwd = fd => fd == File.pwdfd
export let fdIsStdin = fd => fd == File.stdin
export let fdIsStdout = fd => fd == File.stdout
export let fdIsStderr = fd => fd == File.stderr

export let fdFilestats = fd =>
  match (File.fdFilestats(fd)) {
    Ok(stats) => Ok(stats),
    Err(e) => systemErrors(e, "./"),
  }

export let pathFileStats = (fd, path) =>
  match (File.pathFilestats(fd, [File.SymlinkFollow], path)) {
    Err(e) => Err(systemErrors(e, path)),
    Ok(stats) => Ok(stats),
  }

export let statEntity = (file: FilePath) =>
  match (file) {
    Fd(fd) => pathFileStats(fd, "./"),
    Path(path) => pathFileStats(File.pwdfd, path),
    FdPath(fd, path) => pathFileStats(fd, path),
  }

export let entityExists = (file: FilePath) =>
  match (statEntity(file)) {
    Ok(_) => true,
    _ => false,
  }

export let findExistingParent = (fd, path: String) => {
  let rec recurse = (fd, path, pathTo: List<String>) => {
    match (entityExists(FdPath(fd, path))) {
      true => (path, pathTo),
      false => {
        let parent = pathToString(parent(pathFromString(path)))
        recurse(fd, parent, [path, ...pathTo])
      },
    }
  }
  recurse(fd, path, [])
}

/**
 *    Creation
 */

export let createDirectory = (fd, path) => {
  let dirPath = normalisePath(path)
  match (File.pathCreateDirectory(fd, dirPath)) {
    Ok(_) => Ok(void),
    Err(e) => systemErrors(e, path),
  }
}

export let createDir = (filePath: FilePath) => {
  match (filePath) {
    Fd(f) => createDirectory(f, "./"),
    Path(path) => createDirectory(File.pwdfd, path),
    FdPath(fd, path) => createDirectory(fd, path),
  }
}

export let rmDir = (fd, path) =>
  match (File.pathRemoveDirectory(fd, path)) {
    Ok(_) => Ok(void),
    Err(e) => systemErrors(e, path),
  }

export let removeDir = (filePath: FilePath) => {
  match (filePath) {
    Fd(f) => rmDir(f, "./"),
    Path(path) => rmDir(File.pwdfd, path),
    FdPath(fd, path) => rmDir(fd, path),
  }
}

export let rmFile = (fd, path) =>
  match (File.pathUnlink(fd, path)) {
    Err(e) => systemErrors(e, path),
    _ => Ok(void),
  }

export let removeFile = (filePath: FilePath) => {
  match (filePath) {
    Fd(f) => rmFile(f, "./"),
    Path(path) => rmFile(File.pwdfd, path),
    FdPath(fd, path) => rmFile(fd, path),
  }
}

export let touch = (file: FilePath) => {
  let open = (fd, path) => {
    let opened = File.pathOpen(fd, [], path, [File.Create], [], [], [])
    match (opened) {
      Ok(fd) => Ok(fd),
      Err(e) => systemErrors(e, path),
    }
  }
  match (file) {
    Fd(f) => open(f, "./"),
    Path(path) => open(File.pwdfd, path),
    FdPath(f, path) => open(f, path),
  }
}

export let openFile = (file: FilePath, options: PathOpenOptions) => {
  let { lookupFlag, openFlags, rights, inheriting, rwFlags } = options

  let open = (fd, path) => {
    let opened = File.pathOpen(
      fd,
      lookupFlag,
      path,
      openFlags,
      rights,
      inheriting,
      rwFlags
    )
    match (opened) {
      Ok(fd) => Ok(fd),
      Err(e) => systemErrors(e, path),
    }
  }
  match (file) {
    Fd(f) => open(f, "./"),
    Path(path) => open(File.pwdfd, path),
    FdPath(f, path) => open(f, path),
  }
}

export let createFile = (file: FilePath, options: PathOpenOptions) => {
  let { lookupFlag, openFlags, rights, inheriting, rwFlags } = options
  let openFlag = [File.Create, ...openFlags]
  openFile(
    file,
    { lookupFlag, openFlags: openFlag, rights, inheriting, rwFlags }
  )
}

export let openFdCallback = (filePath: FilePath, options, callback) => {
  match (filePath) {
    Fd(fd) => callback(fd, "./"),
    Path(path) =>
      match (openFile(Path(path), options)) {
        Ok(fd) => callback(fd, path),
        Err(e) => systemErrors(e, path),
      },
    FdPath(fd, path) =>
      match (openFile(FdPath(fd, path), options)) {
        Ok(fd) => callback(fd, path),
        Err(e) => systemErrors(e, path),
      },
  }
}

export let fdCallback = (filePath: FilePath, callback) =>
  match (filePath) {
    Fd(fd) => callback(fd, "./"),
    Path(path) => callback(File.pwdfd, path),
    FdPath(fd, path) => callback(fd, path),
  }

export let ls = fd =>
  match (File.fdReaddir(fd)) {
    Ok(entries) => Ok(entries),
    Err(e) => systemErrors(e, "./"),
  }

export let listDir = (filePath: FilePath) => {
  let options = {
    lookupFlag: [],
    openFlags: [],
    rights: [File.FdReaddir, File.PathReadlink],
    inheriting: [],
    rwFlags: [],
  }
  match (filePath) {
    Fd(fd) => ls(fd),
    Path(path) =>
      match (openFile(Path(path), options)) {
        Ok(fd) => ls(fd),
        Err(e) => systemErrors(e, path),
      },
    FdPath(fd, path) =>
      match (openFile(FdPath(fd, path), options)) {
        Ok(fd) => ls(fd),
        Err(e) => systemErrors(e, path),
      },
  }
}

export let reduceEntries = entries =>
  Array.reduce((acc, entry: DirectoryEntry) => {
    let (dirs, files) = acc
    match (entry.filetype) {
      RegularFile => (dirs, [entry.path, ...files]),
      Directory => ([entry.path, ...dirs], files),
      _ => ([], []),
    }
  }, ([], []), entries)

export let listDirPaths = (filePath: FilePath) =>
  match (listDir(filePath)) {
    Ok(entries) => Some(reduceEntries(entries)),
    Err(e) => {
      systemErrors(e, toString(filePath))
      None
    },
  }

let ignoreResultPrint = result => {
  Result.peekErr(e => logError(toString(e) ++ "\n"), result)
}
export let removeDirForce = (fd, rootPath) => {
  let rec recurse = (fd, path) => {

    match (listDirPaths(FdPath(fd, path))) {
      None => void,
      Some((dirs, files)) => {
        List.forEach(p => recurse(fd, normalisePath(path) ++ "/" ++ p), dirs)
        List.forEach(p =>
          ignoreResultPrint(rmFile(fd, normalisePath(path) ++ "/" ++ p)), files)
        ignoreResultPrint(rmDir(fd, path))
      },
    }
  }
  recurse(fd, rootPath)
}

let mkdirp = (fd, paths: List<String>) => {
  let errors = List.reduce((acc, path) => {
    match (createDir(FdPath(fd, path))) {
      Ok(_) => acc,
      Err(e) => [toString(e), ...acc],
    }
  }, [], paths)
  match (List.length(errors) > 0) {
    true => Err(errors),
    false => Ok(void),
  }
}

export let ensureDir = (filePath: FilePath) => {
  let makePath = (fd, path) => {
    let dirPath = normalisePath(path)
    let (_, pathToDir) = findExistingParent(fd, dirPath)
    mkdirp(fd, pathToDir)
  }
  fdCallback(filePath, makePath)
}

export let ensureFile = (filePath: FilePath) => {
  let makePath = (fd, path) => {
    let dirPath = pathToString(parent(pathFromString(normalisePath(path))))
    let (_, pathToDir) = findExistingParent(fd, dirPath)
    mkdirp(fd, pathToDir)
    touch(filePath)
  }
  fdCallback(filePath, makePath)
}

export let writeFile =
  (
    filePath: FilePath,
    rwFlags: List<FdFlag>,
    data: String,
  ) => {
  let options = {
    lookupFlag: [],
    openFlags: [File.Create],
    rights: [File.FdWrite],
    inheriting: [],
    rwFlags,
  }

  let write = (fd, path) =>
    match (createFile(filePath, options)) {
      Ok(fd) => {
        match (File.fdWrite(fd, data)) {
          Ok(x) => Ok(x),
          Err(e) => systemErrors(e, path),
        }
      },
      Err(e) => systemErrors(e, toString(filePath)),
    }

  fdCallback(filePath, write)
}

export let readFile = (filePath: FilePath, rwFlags: List<FdFlag>, size) => {
  let options = {
    lookupFlag: [],
    openFlags: [],
    rights: [File.FdRead, File.FdSeek, File.FdTell],
    inheriting: [],
    rwFlags,
  }

  let read = (fd, path) =>
    match (File.fdRead(fd, size)) {
      Ok(x) => Ok((fd, x)),
      Err(e) => systemErrors(e, path),
    }

  openFdCallback(filePath, options, read)
}

export let readFileFd = (fd, size: Number) =>
  match (File.fdRead(fd, size)) {
    Ok(x) => Ok(x),
    Err(e) => systemErrors(e, toString(fd)),
  }
